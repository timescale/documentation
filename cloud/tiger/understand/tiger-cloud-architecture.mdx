---
title: The Tiger Cloud architecture
description: A whitepaper detailing the architectural choices and optimizations for real-time analytics that power TimescaleDB and Tiger Cloud
products: [cloud, mst, self_hosted]
keywords: [real-time analytics, tiger cloud, timescaledb, time-series, whitepaper]
---

import { COMPANY, PG, CLOUD_LONG, SERVICE_SHORT, TIMESCALE_DB  }  from '/snippets/vars.mdx';


{CLOUD_LONG} offers managed database services that provide a stable and reliable environment for your
applications. Each {SERVICE_SHORT} is based on a {PG} database instance and the {TIMESCALE_DB} extension.

By making use of incrementally updated materialized views and advanced analytical functions, {TIMESCALE_DB} reduces
compute overhead and improves query efficiency. Developers can continue using familiar SQL workflows and tools, while
benefiting from a database purpose-built for fast, scalable analytics.

This document outlines the architectural choices and optimizations that power {CLOUD_LONG}’s performance and
scalability while preserving {PG}’s reliability and transactional guarantees.

Want to read this whitepaper from the comfort of your own computer?


    <Tag type="download">[TigerData architecture for real-time analytics (PDF)](https://assets.timescale.com/docs/downloads/tigerdata-whitepaper.pdf)</Tag>


## Cloud-native architecture

Real-time analytics requires a scalable, high-performance, and cost-efficient database that can handle high-ingest rates and low-latency queries without overprovisioning. {CLOUD_LONG} is designed for elasticity, enabling independent scaling of storage and compute, workload isolation, and intelligent data tiering.


### Independent storage and compute scaling

Real-time applications generate continuous data streams while requiring instant querying of both fresh and historical data. Traditional databases force users to pre-provision fixed storage, leading to unnecessary costs or unexpected limits. {CLOUD_LONG} eliminates this constraint by dynamically scaling storage based on actual usage:



* Storage expands and contracts automatically as data is added or deleted, avoiding manual intervention.
* Usage-based billing ensures costs align with actual storage consumption, eliminating large upfront allocations.
* Compute can be scaled independently to optimize query execution, ensuring fast analytics across both recent and historical data.

With this architecture, databases grow alongside data streams, enabling seamless access to real-time and historical insights while efficiently managing storage costs.


### Workload isolation for real-time performance

Balancing high-ingest rates and low-latency analytical queries on the same system can create contention, slowing down performance. {CLOUD_LONG} mitigates this by allowing read and write workloads to scale independently:



* The primary database efficiently handles both ingestion and real-time rollups without disruption.
* Read replicas scale query performance separately, ensuring fast analytics even under heavy workloads.



    <img
        class="main-content__illustration"
        width="80%"
        src="https://assets.timescale.com/docs/images/compute-compute-seperation.png"
        alt=""
    />


This separation ensures that frequent queries on fresh data don’t interfere with ingestion, making it easier to support live monitoring, anomaly detection, interactive dashboards, and alerting systems.


### Intelligent data tiering for cost-efficient real-time analytics

Not all real-time data is equally valuable—recent data is queried constantly, while older data is accessed less frequently. {CLOUD_LONG} can be configured to automatically tier data to cheaper bottomless object storage, ensuring that hot data remains instantly accessible, while historical data is still available.



    <img
        class="main-content__illustration"
        width="80%"
        src="https://assets.timescale.com/docs/images/tiering.png"
        alt=""
    />




* **Recent, high-velocity data** stays in high-performance storage for ultra-fast queries.
* **Older, less frequently accessed data** is automatically moved to cost-efficient object storage but remains queryable and available for building continuous aggregates.

While many systems support this concept of data cooling, {TIMESCALE_DB} ensures that the data can still be queried from the same hypertable regardless of its current location. For real-time analytics, this means applications can analyze live data streams without worrying about storage constraints, while still maintaining access to long-term trends when needed.


### Cloud-native database observability

Real-time analytics doesn’t just require fast queries—it requires the ability to understand why queries are fast or slow, where resources are being used, and how performance changes over time. That’s why {CLOUD_LONG} is built with deep observability features, giving developers and operators full visibility into their database workloads.

At the core of this observability is Insights, {CLOUD_LONG}’s built-in query monitoring tool. Insights captures
per-query
statistics from our whole fleet in real time, showing you exactly how your database is behaving under load. It tracks key metrics like execution time, planning time, number of rows read and returned, I/O usage, and buffer cache hit rates—not just for the database as a whole, but for each individual query.

Insights lets you do the following:



* Identify slow or resource-intensive queries instantly
* Spot long-term performance regressions or trends
* Understand query patterns and how they evolve over time
* See the impact of schema changes, indexes, or continuous aggregates on workload performance
* Monitor and compare different versions of the same query to optimize execution

All this is surfaced through an intuitive interface, available directly in {CLOUD_LONG}, with no instrumentation or external monitoring infrastructure required.

Beyond query-level visibility, {CLOUD_LONG} also exposes metrics around service resource consumption, compression, continuous aggregates, and data tiering, allowing you to track how data moves through the system—and how those background processes impact storage and query performance.

Together, these observability features give you the insight and control needed to operate a real-time analytics database at scale, with confidence, clarity, and performance you can trust**.**


## Ensuring reliability and scalability

Maintaining high availability, efficient resource utilization, and data durability is essential for real-time applications. {CLOUD_LONG} provides robust operational features to ensure seamless performance under varying workloads.

* **High-availability (HA) replicas**: deploy multi-AZ HA replicas to provide fault tolerance and ensure minimal downtime. In the event of a primary node failure, replicas are automatically promoted to maintain service continuity.
* **Connection pooling**: optimize database connections by efficiently managing and reusing them, reducing overhead and improving performance for high-concurrency applications.
* **Backup and recovery**: leverage continuous backups, Point-in-Time Recovery (PITR), and automated snapshotting to protect against data loss. Restore data efficiently to minimize downtime in case of failures or accidental deletions.

These operational capabilities ensure {CLOUD_LONG} remains reliable, scalable, and resilient, even under demanding real-time workloads.


## Conclusion

Real-time analytics is critical for modern applications, but traditional databases struggle to balance high-ingest performance, low-latency queries, and flexible data mutability. {CLOUD_LONG} extends {PG} to solve this challenge, combining automatic partitioning, hybrid row-columnar storage, and intelligent compression to optimize both transactional and analytical workloads.

With continuous aggregates, hyperfunctions, and advanced query optimizations, {CLOUD_LONG} ensures sub-second queries
even on massive datasets that combine current and historic data. Its cloud-native architecture further enhances scalability with independent compute and storage scaling, workload isolation, and cost-efficient data tiering—allowing applications to handle real-time and historical queries seamlessly.

For developers, this means building high-performance, real-time analytics applications without sacrificing SQL compatibility, transactional guarantees, or operational simplicity.

{CLOUD_LONG} delivers the best of {PG}, optimized for real-time analytics.
