---
title: Compact state aggregation overview
sidebarTitle: Overview
description: Track the amount of time spent in each discrete state with compact_state_agg functions
---

<Icon icon="flask" /> Early access 1.5.0

Track the amount of time a system or value spends in each discrete state. For example, use the `compact_state_agg` functions to track how much time a system spends in `error`, `running`, or `starting` states.

`compact_state_agg` is designed to work with a relatively small number of states. It might not perform well on datasets where states are mostly distinct between rows.

If you need to track when each state is entered and exited, use the [`state_agg`][state_agg] functions. If you need to track the liveness of a system based on a heartbeat signal, consider using the [`heartbeat_agg`][heartbeat_agg] functions.

## Two-step aggregation

This group of functions uses the two-step aggregation pattern.

Rather than calculating the final result in one step, you first create an intermediate aggregate by using the aggregate function.

Then, use any of the accessors on the intermediate aggregate to calculate a final result. You can also roll up multiple intermediate aggregates with the rollup functions.

The two-step aggregation pattern has several advantages:

1.  More efficient because multiple accessors can reuse the same aggregate
1.  Easier to reason about performance, because aggregation is separate from final computation
1.  Easier to understand when calculations can be rolled up into larger intervals, especially in window functions and [continuous aggregates][caggs]
1.  Can perform retrospective analysis even when underlying data is dropped, because the intermediate aggregate stores extra information not available in the final result

To learn more, see the [blog post on two-step aggregates][blog-two-step-aggregates].

## Functions in this group

### Aggregate
- [`compact_state_agg()`][compact_state_agg]: aggregate state data into an intermediate form for further computation

### Accessors
- [`duration_in()`][duration_in]: get the total duration in the specified states
- [`interpolated_duration_in()`][interpolated_duration_in]: get the total duration in the specified states, interpolating values at the boundary
- [`into_values()`][into_values]: return an array of `(state, duration)` pairs from the aggregate

### Rollup
- [`rollup()`][rollup]: combine multiple intermediate aggregates

[two-step-aggregation]: #two-step-aggregation
[blog-two-step-aggregates]: https://www.timescale.com/blog/how-postgresql-aggregation-works-and-how-it-inspired-our-hyperfunctions-design
[caggs]: /use-timescale/continuous-aggregates/about-continuous-aggregates/
[heartbeat_agg]: /api-reference/timescaledb/hyperfunctions/state-tracking/heartbeat_agg/
[state_agg]: /api-reference/timescaledb/hyperfunctions/state-tracking/state_agg/
[compact_state_agg]: /api-reference/timescaledb/hyperfunctions/state-tracking/compact_state_agg/compact_state_agg
[duration_in]: /api-reference/timescaledb/hyperfunctions/state-tracking/compact_state_agg/duration_in
[interpolated_duration_in]: /api-reference/timescaledb/hyperfunctions/state-tracking/compact_state_agg/interpolated_duration_in
[into_values]: /api-reference/timescaledb/hyperfunctions/state-tracking/compact_state_agg/into_values
[rollup]: /api-reference/timescaledb/hyperfunctions/state-tracking/compact_state_agg/rollup