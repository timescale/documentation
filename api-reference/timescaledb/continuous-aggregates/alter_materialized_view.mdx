---
title: ALTER MATERIALIZED VIEW (Continuous Aggregate)
description: Change an existing continuous aggregate
sidebarTitle: ALTER MATERIALIZED VIEW
topics: [continuous aggregates]
keywords: [continuous aggregates]
tags: [materialized views, hypertables, alter, change]
license: community
type: command
products: [cloud, self_hosted, mst]
---

You use the `ALTER MATERIALIZED VIEW` statement to modify some of the `WITH`
clause [options][create_materialized_view] for a continuous aggregate view. You can only set the `continuous` and `create_group_indexes` options when you [create a continuous aggregate][create_materialized_view]. `ALTER MATERIALIZED VIEW` also supports the following
[PostgreSQL clauses][postgres-alterview] on the continuous aggregate view:

*   `RENAME TO`: rename the continuous aggregate view
*   `RENAME [COLUMN]`: rename the continuous aggregate column
*   `SET SCHEMA`: set the new schema for the continuous aggregate view
*   `SET TABLESPACE`: move the materialization of the continuous aggregate view to the new tablespace
*   `OWNER TO`: set a new owner for the continuous aggregate view

## Samples

- Enable real-time aggregates for a continuous aggregate:

   ```sql
   ALTER MATERIALIZED VIEW contagg_view SET (timescaledb.materialized_only = false);
   ```

- Enable hypercore for a continuous aggregate:

   <Icon icon="circle-play" iconType="duotone" /> Since 2.18.0

   ```sql
    ALTER MATERIALIZED VIEW contagg_view SET (
     timescaledb.enable_columnstore = true,
     timescaledb.segmentby = 'symbol' );
   ```

- Rename a column for a continuous aggregate:

   ```sql
   ALTER MATERIALIZED VIEW contagg_view RENAME COLUMN old_name TO new_name;
   ```

## Arguments

The syntax is:

```sql
ALTER MATERIALIZED VIEW <view_name> SET ( timescaledb.<argument> =  <value> [, ... ] )
```

| Name | Type | Default | Required | Description |
|-|-|-|-|-|
| `view_name` | TEXT | - | âœ” | The name of the continuous aggregate view to be altered. |
| `timescaledb.materialized_only` | BOOLEAN | `true` | - | Enable real-time aggregation. |
| `timescaledb.enable_columnstore` | BOOLEAN | `true` | - | Enable columnstore. Effectively the same as `timescaledb.compress`. Since 2.18.0 |
| `timescaledb.compress` | TEXT | Disabled | - | Enable compression. |
| `timescaledb.orderby` | TEXT | Descending order on the time column in `table_name`. | - | Set the order in which items are used in the columnstore. Specified in the same way as an `ORDER BY` clause in a `SELECT` query. Since 2.18.0 |
| `timescaledb.compress_orderby` | TEXT | Descending order on the time column in `table_name`. | - | Set the order used by compression. Specified in the same way as the `ORDER BY` clause in a `SELECT` query. |
| `timescaledb.segmentby` | TEXT | No segementation by column. | - | Set the list of columns used to segment data in the columnstore for `table`. An identifier representing the source of the data such as `device_id` or `tags_id` is usually a good candidate. Since 2.18.0 |
| `timescaledb.compress_segmentby` | TEXT | No segementation by column. | - | Set the list of columns used to segment the compressed data. An identifier representing the source of the data such as `device_id` or `tags_id` is usually a good candidate. |
| `column_name` | TEXT | - | - | Set the name of the column to order by or segment by. |
| `timescaledb.compress_chunk_time_interval` | TEXT | - | - | Reduce the total number of compressed/columnstore chunks for `table`. If you set `compress_chunk_time_interval`, compressed/columnstore chunks are merged with the previous adjacent chunk within `chunk_time_interval` whenever possible. These chunks are irreversibly merged. If you call to [decompress][decompress]/[convert_to_rowstore][convert_to_rowstore], merged chunks are not split up. You can call `compress_chunk_time_interval` independently of other compression settings; `timescaledb.compress`/`timescaledb.enable_columnstore` is not required. |
| `timescaledb.enable_cagg_window_functions` | BOOLEAN | `false` | - | EXPERIMENTAL: enable window functions on continuous aggregates. Support is experimental, as there is a risk of data inconsistency. For example, in backfill scenarios, buckets could be missed. |
| `timescaledb.chunk_interval` (formerly `timescaledb.chunk_time_interval`) | INTERVAL | 10x the original hypertable. | - | Set the chunk interval. Renamed in TimescaleDB V2.20. |

[create_materialized_view]: /api-reference/timescaledb/continuous-aggregates/create_materialized_view#arguments
[postgres-alterview]: https://www.postgresql.org/docs/current/sql-alterview.html
[create-cagg]: /use-timescale/latest/continuous-aggregates/create-a-continuous-aggregate/
[default_table_access_method]: https://www.postgresql.org/docs/17/runtime-config-client.html#GUC-DEFAULT-TABLE-ACCESS-METHOD
[convert_to_rowstore]: /api-reference/timescaledb/hypercore/convert_to_rowstore
[decompress]: /api-reference/timescaledb/compression/decompress_chunk
